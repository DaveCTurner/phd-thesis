\subsection{Syntax}
\label{syntax}

\subsubsection{Preliminaries}

Fix a set of (term) variables $\termvar{x}, \termvar{y}, \ldots$ and a set of
type variables $P, \ldots$, each with a discrete permutation action.  Also fix
a set $\mathcal L$ of nominal label-sets $L, \ldots$.  $\mathcal L$ also has
the discrete permutation action. Labels will be written $\ell, \ell_0, \ldots
\in L$. Note that each $L \in \mathcal L$ does not necessarily have the discrete
permutation action, so that for some labels $\ell$ and some permutations $\sigma$
it may be the case that $\sigma \cdot \ell \neq \ell$.

\subsubsection{Syntax of Types}

Types are given by the grammar \[\typeP, \typeQ ::= \typevar{P} \mid
\typelift{\typeP} \mid \typemap{\typeQ}{\typeP} \mid \typedelta{\typeP} \mid
\stdtypesum \mid \typerec{j}{P}{\typeP}, \] where $P$ is a type variable,
$\vec{P}$ is a list of type variables, and $\typerec{j}{P}{\typeP}$ binds
$\vec{P}$. A closed type is a type with no free variables, and in the
following, closed types will normally simply be called `types'. The permutation
action on types is the discrete action: for all types $\typeP$ and permutations
$\sigma$, $\sigma \cdot \typeP = \typeP$.

\subsubsection{Syntax of Environments}

Environments are given by the grammar \[ \Gamma ::= \envempty \mid
\envcombine{\Gamma}{\envvarfresh{x}{\typeP}{s}}\] where $\termvar{x}$ ranges
over variables, $\typeP$ ranges over types and $s$ ranges over finite sets of
names, and the variables in $\Gamma$ are distinct from $\termvar{x}$. The
intended meaning of $\envvarfresh{x}{\typeP}{s}$ is that the variable
$\termvar{x}$ takes values of type $\typeP$ that are assumed to be fresh for
$s$.  The set of environments may be equipped with a permutation action which
simply permutes the freshness assumptions: \[ \sigma \cdot \envempty =
\envempty \qquad\text{and}\qquad \sigma \cdot
(\envcombine{\Gamma}{\envvarfresh{x}{\typeP}{s}}) = \envcombine{(\sigma \cdot
\Gamma)}{\envvarfresh{x}{\typeP}{(\sigma \cdot s)}},\] and is therefore a
nominal set.

Define $\envcombine{\Gamma}{\Lambda}$ is defined by the obvious recursion \[
\envcombine{\Gamma}{\envempty} = \Gamma \qquad\text{and}\qquad
\envcombine{\Gamma}{(\envcombine{\Lambda}{\envvarfresh{x}{\typeP}{s}})} =
\envcombine{(\envcombine{\Gamma}{\Lambda})}{\envvarfresh{x}{\typeP}{s} }, \]
which only makes sense when the variables in $\Gamma$ and $\Lambda$ to be
distinct. It is sometimes useful to be able to simultaneously alter all the
freshness assumptions in an environment: define $\envfresh{\Gamma}{s}$ by
\[\envfresh{\envempty}{s} = \envempty \qquad\text{and}\qquad
\envfresh{\bigl(\envcombine{\Gamma}{\envvarfresh{x}{\typeP}{s'}}\bigr)}{s} =
\envcombine{\envfresh{\Gamma}{s}}{\envvarfresh{x}{\typeP}{s' \cup s}},\] and
define $\envrestrict{\Gamma}{s}$ by \[\envrestrict{\envempty}{s} = \envempty
\qquad\text{and}\qquad
\envrestrict{\bigl(\envcombine{\Gamma}{\envvarfresh{x}{\typeP}{s'}}\bigr)}{s} =
\envcombine{\bigl(\envrestrict{\Gamma}{s}\bigr)}{\envvarfresh{x}{\typeP}{s'
\cap s}}.\] Finally, omit $\envempty$ where it is unambiguous to do so. In
particular, write $\envvarfresh{x}{\typeP}{s}$ for the single-variable
environment $\envcombine{()}{\envvarfresh{x}{\typeP}{s}}$.

\vfill\pagebreak

\subsubsection{Syntax of Terms}

Terms are given by the following grammar, where $\termvar{x}$ ranges over
variables, $a$ ranges over names, $s$ over finite sets of names, $p$ over
actions, $\ell$ over labels and $\typeP$ over types.
\[\begin{array}{lclcl} t, u &::=&
\quad \termvar{x} \bigmid \rec{x}{t} &\qquad&\text{variables; recursion}
\\
%
&&\bigmid \bang{t} \bigmid \matchz{s}{u}{p}{x}{t}{\typeP} && \text{prefixing}\\
%
&&\bigmid \abstract{x}{t} \bigmid \apply{t}{u} &&\text{abstraction and
application} \\
%
&&\bigmid \new{a}{t} \bigmid \newapply{t}{a} && \text{binding and concretion}\\
%
&&\bigmid \linj{\ell}{t} \bigmid \lproj{\ell}{t} &&
\text{labelling}\\
%
&&\bigmid \ndsum{i}{I}{t_i} && \text{nondeterminstic sum} \\
%
&&\bigmid \abs{t} \bigmid \rep{t} && \text{recursive types}\\
\end{array}\]
The forms \[\rec{x}{t} \qquad \matchz{s}{u}{p}{x}{t}{\typeP} \qquad
\abstract{x}{t}\] all bind $\termvar{x}$ in $t$, and the set of free variables
of $t$, $\fv{t}$, is defined in the usual way.

The nondeterministic sum may be over an infinite set $I$, but there are
constraints to ensure that it behaves properly: the mapping $i \mapsto t_i$ is
a finitely supported function from a nominal set $I$ to the set of terms, and
is such that there exists a finite set $X$ of variables such that for all $i$,
the free variables of $t_i$ are contained in $X$.  Write $\inactive$ for the
term $\ndsum{i}{\varnothing} t_i$.

Although the binding of variables is treated informally, the binding of the
name $a$ in the form $\new{a}{t}$ must be treated more carefully. Strictly
speaking, the form $\new{a}{t}$ is the equivalence class of pairs of names and
terms that contains $(a, t)$ under the usual $\alpha$-equivalence relation
\[(a, t) \sim (a', t') \quad\Leftrightarrow\quad \exists b \freshfor (a, a', t,
t'). (ab) \cdot t = (a'b) \cdot t'.\] Therefore for any fresh name $b$,
$\new{a}{t} = \new{b}{(ab) \cdot t}$, where the equality in this statement is
literally equality, not simply equality-up-to-$\alpha$.
TODO Chicken-and-egg problem here: can't say $b \freshfor t$ without defining
the permutation action on $t$.

\subsubsection{Syntax of Actions}

Actions are given by the following grammar, where $t$ ranges over closed terms
(i.e. those terms $t$ with $\fv{t} = \varnothing$), $a$ ranges over names and
$\ell$ over labels.
\[\begin{array}{lclcl} p &::=&
\quad \bangaction &\qquad&\text{prefixing}
\\
%
&&\bigmid \labelaction{\ell}{p} && \text{labelled actions}\\
%
&&\bigmid \mapaction{t}{p} &&\text{higher-order actions} \\
%
&&\bigmid \absaction{p} && \text{recursive type actions}\\
%
&&\bigmid \newaction{a}{p} && \text{new name actions}\\
\end{array}\]
The form $\newaction{a}{p}$ binds the name $a$ in the same way that $a$ is
bound in the term $\new{a}{t}$.

The permutation action on terms and actions is as follows.
\[\begin{array}{rclcrcl} \sigma \cdot \termvar{x} &=& \termvar{x} &\qquad&
%
\sigma \cdot (\rec{x}{t}) &=& \rec{x}{(\sigma \cdot t)} \\
%
\sigma \cdot (\bang{t}) &=& \bang{(\sigma \cdot t)} &&
%
\sigma \cdot \left(\ndsum{i}{I}{t_i}\right) &=& \ndsum{i}{I}{(\sigma \cdot
t_i)} \\
%
\multicolumn{3}{c}{\sigma \cdot (\matchz{s}{u}{p}{x}{t}{\typeP})} &=&
\multicolumn{3}{c}{ \matchz{(\sigma \cdot s)}{(\sigma \cdot u)}{(\sigma \cdot
p)}{x}{(\sigma \cdot t)}{\typeP}} \\ \sigma \cdot (\abstract{x}{t}) &=&
\abstract{x}{(\sigma \cdot t)} &&
%
\sigma \cdot (\apply{t}{u}) &=& \apply{(\sigma \cdot t)}{(\sigma \cdot u)} \\
%
\sigma \cdot (\new{a}{t}) &=& \new{(\sigma \cdot a)}{(\sigma \cdot t)} &&
%
\sigma \cdot (\newapply{t}{a}) &=& 
\newapply{(\sigma \cdot t)}{(\sigma \cdot a)} \\
%
\sigma \cdot (\linj{\ell}{t}) &=& \linj{(\sigma \cdot \ell)}{(\sigma \cdot t)} &&
%
\sigma \cdot (\lproj{\ell}{t}) &=& \lproj{(\sigma \cdot \ell)}{(\sigma \cdot t)} \\
%
\sigma \cdot (\abs{t}) &=& \abs{(\sigma \cdot t)} &&
%
\sigma \cdot (\rep{t}) &=& \rep{(\sigma \cdot t)} \\
%
\\
%
\sigma \cdot \bangaction &=& \bangaction &&
%
\sigma \cdot (\labelaction{\ell}{p}) &=& \labelaction{(\sigma \cdot \ell)}{(\sigma \cdot p)} \\
%
\sigma \cdot (\mapaction{t}{p}) &=& \mapaction{(\sigma \cdot t)}{(\sigma \cdot p)} &&
%
\sigma \cdot (\newaction{a}{p}) &=& \newaction{(\sigma \cdot a)}{(\sigma \cdot p)} \\
%
\sigma \cdot (\absaction{p}) &=& \absaction{(\sigma \cdot p)} \\
\end{array}\]

% vim: set filetype=tex foldlevel=0 cms=\%%s tw=0 nowrap:
